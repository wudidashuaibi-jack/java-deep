1.对象在内存中的存储结构（ClassStudy.java）
    四部分：markword、classpointer、instance data、padding
    markword:存放锁的信息、hashcode的信息、gc标记 8bit
    classpionter: 类指针 4bit
    instance data: 存放实例化的变量，对象里存在引用类型的时候，boolean、char、short的总字节数之和会内部补齐到4的倍数
    padding: 集装箱理论，整个对象的字节必须是8的倍数
2.对象是如何定位的
    直接指针与间接指针（句柄）
    直接指针指向对象，再通过对象里的类指针找到对象的类
    间接指针指向某个地址（含有两个指针一个实例指针一个类指针）再找到这个对象
    优缺点：直接指针在gc回收的时候需要不断的改变、间接指针不需要改变
3.对象在内存上如何分配的
    1.逃逸分析：如果对象不会被外部访问，就把它标量替换分解放到栈中，然后出栈死亡（前提：栈上空间足够） 逃逸分析优点：节省堆内存、减少gc压力
    2.如果逃逸分析不通过，判断对象的大小，大的话直接放到老年代（FGC回收），小的话放到TLAB（本地线程分配缓存区），解决地址竞争，为每个线程分配一块私有的堆内存。
    talb也是在新生代区域，当ygc回收器回收时标记标记年龄，age=15到老年代，fgc回收
4.为什么不用c++对象直接表示java对象
    1.c++对象中有个Virtual table 虚函数表用于实现多态，同等条件下，如果用c++直接表示java对象，c++对象内存会大于java对象
5.class实例是放在方法区还是在堆上
    先找到方法区里的c++class对象指针，再找到heap里的class对象
6.对象的创建过程
    半初始化：申请内存空间，属性赋默认值（c++ new对象对象属性的默认值是多少？？？） 调用构造方法 建立连接，把堆内存的地址赋值给局部变量
7.指令重排（Disorder.java）
8.DCL要不要加锁（Mrg04.java）
gc垃圾回收：
    1.找垃圾：引用计数法、可达性分析
    2.收垃圾：标记清除法、标记整理、复制算法、分代回收算法
引用计数法：根据对象的地址判断是否在栈中被引用，如果计数为0代表需要被回收
可达性分析：从引用的角度出发查找对象的地址，两次gc不被找到的对象视为可回收
标记清除法: 顾名思义，将标记的对象清除 缺点：碎片化严重
标记整理：把存活对象聚合在一起放到边界、然后再清除垃圾
复制算法：把内存分成两半一次只用一半，回收时把存活对象移动到另一半，这一半全部清空
分代回收算法：根据对象的生命周期不同，选取不同的回收算法
    年轻代算法：内存分为一大块两小块 一次使用一大块和一小块，回收时用标记整理法把存活对象放到小块里，放不下的话会移动到老生代，再使用复制算法移动到另一小块
    老年代算法：标记整理算法

    

